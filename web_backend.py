#!/usr/bin/env python3
"""
Web Backend for Investment Backtest Analyzer
Provides API endpoint to run backtests with different parameters
"""

import sys
import json
import subprocess
import pandas as pd
import tempfile
import os
from pathlib import Path

def run_backtest_with_params(params):
    """
    Run backtest with specified parameters and return results
    """
    # Create a temporary copy of backtest_strategy.py with modified parameters
    script_dir = Path(__file__).parent
    original_file = script_dir / "backtest_strategy.py"
    
    # Read original file
    with open(original_file, 'r', encoding='utf-8') as f:
        content = f.read()
    
    # Replace configuration parameters
    replacements = {
        'NUM_INVESTORS = 5': f'NUM_INVESTORS = {params.get("num_investors", 5)}',
        'START_YEAR = 2012': f'START_YEAR = {params.get("start_year", 2012)}',
        'END_YEAR = 2026': f'END_YEAR = {params.get("end_year", 2026)}',
        'HAS_RELOCATION = True': f'HAS_RELOCATION = {params.get("rebalancing", True)}',
        'SELECTION_MODE = 3': f'SELECTION_MODE = {params.get("selection_mode", 3)}',
        'TOP_PICKS_PER_INVESTOR = 3': f'TOP_PICKS_PER_INVESTOR = {params.get("top_picks", 3)}',
        'MIN_TOP1_PCT = 15': f'MIN_TOP1_PCT = {params.get("min_top1_pct", 15)}',
        'RANDOM_SEED = 1207': f'RANDOM_SEED = {params.get("random_seed", 1207)}',
    }
    
    # Apply replacements
    modified_content = content
    for old, new in replacements.items():
        modified_content = modified_content.replace(old, new)
    
    # Write temporary file
    with tempfile.NamedTemporaryFile(mode='w', suffix='_backtest.py', delete=False, encoding='utf-8') as f:
        f.write(modified_content)
        temp_file = f.name
    
    try:
        # Run the backtest
        result = subprocess.run([sys.executable, temp_file], 
                              capture_output=True, 
                              text=True, 
                              cwd=script_dir,
                              timeout=300)  # 5 minutes timeout
        
        if result.returncode != 0:
            return {
                'success': False,
                'error': f"Backtest failed: {result.stderr}",
                'stdout': result.stdout
            }
        
        # Read results from CSV files
        results = parse_backtest_results(script_dir, params)
        results['success'] = True
        results['stdout'] = result.stdout
        return results
        
    except subprocess.TimeoutExpired:
        return {
            'success': False,
            'error': "Backtest timed out after 5 minutes"
        }
    except Exception as e:
        return {
            'success': False,
            'error': f"Unexpected error: {str(e)}"
        }
    finally:
        # Clean up temporary file
        try:
            os.unlink(temp_file)
        except:
            pass

def parse_backtest_results(script_dir, params):
    """
    Parse the results from CSV files generated by the backtest
    """
    results = {}
    
    try:
        # Read transactions
        transactions_file = script_dir / "backtest_transactions.csv"
        if transactions_file.exists():
            df_trans = pd.read_csv(transactions_file)
            
            # Calculate portfolio performance
            buy_transactions = df_trans[df_trans['accion'] == 'COMPRA']
            sell_transactions = df_trans[df_trans['accion'] == 'VENTA']
            
            total_invested = buy_transactions['valor'].sum()
            total_returned = sell_transactions['valor'].sum()
            
            if total_invested > 0:
                total_return = (total_returned - total_invested) / total_invested
                years = params.get('end_year', 2026) - params.get('start_year', 2012)
                if years > 0:
                    cagr = (1 + total_return) ** (1/years) - 1
                else:
                    cagr = 0
                
                results['portfolio_cagr'] = cagr * 100
                results['portfolio_total_return'] = total_return * 100
                results['total_invested'] = total_invested
                results['total_returned'] = total_returned
                results['transaction_count'] = len(df_trans)
        
        # Simulate benchmark returns (S&P 500 and NASDAQ)
        # In a real implementation, you'd calculate these from actual data
        years = params.get('end_year', 2026) - params.get('start_year', 2012)
        results['sp500_cagr'] = 10.5  # Historical average
        results['nasdaq_cagr'] = 11.8  # Historical average
        results['alpha'] = results.get('portfolio_cagr', 0) - results['sp500_cagr']
        
        # Generate performance timeline
        results['timeline'] = generate_performance_timeline(script_dir, params)
        
    except Exception as e:
        results['parse_error'] = str(e)
    
    return results

def generate_performance_timeline(script_dir, params):
    """
    Generate quarterly performance timeline for the chart
    """
    try:
        transactions_file = script_dir / "backtest_transactions.csv"
        if not transactions_file.exists():
            return []
            
        df_trans = pd.read_csv(transactions_file)
        df_trans['fecha'] = pd.to_datetime(df_trans['fecha'])
        
        # Group by quarter and calculate cumulative performance
        timeline = []
        start_year = params.get('start_year', 2012)
        end_year = params.get('end_year', 2026)
        
        portfolio_value = 100  # Starting value
        sp500_value = 100
        nasdaq_value = 100
        
        for year in range(start_year, end_year + 1):
            for quarter in [1, 2, 3, 4]:
                # Simulate quarterly returns
                quarter_end = f"{year}-{quarter*3:02d}-{[31,30,30,31][quarter-1]:02d}"
                
                # Portfolio return based on transactions in this period
                period_transactions = df_trans[
                    df_trans['fecha'].dt.year == year
                ]
                
                if len(period_transactions) > 0:
                    # Calculate return based on buy/sell transactions
                    buys = period_transactions[period_transactions['accion'] == 'COMPRA']
                    sells = period_transactions[period_transactions['accion'] == 'VENTA']
                    
                    if len(sells) > 0 and len(buys) > 0:
                        quarter_return = (sells['valor'].sum() - buys['valor'].sum()) / buys['valor'].sum()
                        portfolio_value *= (1 + quarter_return / 4)  # Quarterly
                
                # Simulate benchmark returns
                sp500_quarterly = 0.105 / 4  # 10.5% annual
                nasdaq_quarterly = 0.118 / 4  # 11.8% annual
                
                sp500_value *= (1 + sp500_quarterly)
                nasdaq_value *= (1 + nasdaq_quarterly)
                
                timeline.append({
                    'date': f"{year}Q{quarter}",
                    'portfolio': round(portfolio_value, 2),
                    'sp500': round(sp500_value, 2),
                    'nasdaq': round(nasdaq_value, 2)
                })
        
        return timeline
        
    except Exception as e:
        return []

if __name__ == "__main__":
    # Example usage for testing
    if len(sys.argv) > 1:
        # Parse parameters from command line JSON
        params = json.loads(sys.argv[1])
    else:
        # Default parameters
        params = {
            "num_investors": 5,
            "start_year": 2012,
            "end_year": 2024,
            "rebalancing": True,
            "selection_mode": 3,
            "top_picks": 3,
            "min_top1_pct": 15,
            "random_seed": 1207
        }
    
    results = run_backtest_with_params(params)
    print(json.dumps(results, indent=2))
